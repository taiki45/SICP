(provide #f)
(define (prime? n)
  (= n (smallest-divisor n)))
(define (smallest-divisor n)
  (fine-divisor n 2))
(define (fine-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (fine-divisor n (+ test-divisor 1)))))
(define (square n) (* n n))
(define (divides? a b)
  (= (remainder b a) 0))

(define-macro (my-delay exp) `(lambda () ,exp))
;(define-macro (my-delay exp) `(memo-proc (lambda () ,exp)))
(define (stream-null? s) (null? s))
(define stream-null '())
(define (my-force delayed) (delayed))
(define (memo-proc proc)
  (let ((already-run? #f) (result #f))
    (lambda ()
      (if (not already-run?)
        (begin (set! result (proc))
               (set! already-run? #t)
               result)
        result))))
(define-macro (stream-cons a b)
  `(cons ,a (my-delay ,b)))
(define (stream-car s) (car s))
(define (stream-cdr s) (my-force (cdr s)))
(define (displayl item)
  (display item)(newline))
(define (stream-ref s n)
  (cond ((null? s) '())
        ((= 0 n) (stream-car s))
        (else (stream-ref (stream-cdr s) (- n 1)))))
(define (stream-map proc s)
  (if (null? s)
    '()
    (stream-cons (proc (stream-car s))
                 (stream-map proc (stream-cdr s)))))
(define (stream-for-each proc s)
  (if (null? s)
    '()
    (begin (proc (stream-car s))
           (stream-for-each proc (stream-cdr s)))))
(define (stream-enumrate-interval init limit)
  (if (> init limit)
    '()
    (stream-cons init (stream-enumrate-interval (+ 1 init) limit))))
(define (stream-filter pred s)
  (cond ((stream-null? s) '())
        ((pred (stream-car s))
         (stream-cons (stream-car s) (stream-filter pred (stream-cdr s))))
        (else (stream-filter pred (stream-cdr s)))))
